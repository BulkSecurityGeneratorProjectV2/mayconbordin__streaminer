{"name":"Streaminer","tagline":"A collection of algorithms for mining data streams","body":"Streaminer\r\n==========\r\n\r\nA collection of algorithms for mining data streams, including frequent itemsets, quantiles, sampling, moving averages, set membership and cardinality.\r\n\r\n## Releases\r\n\r\nMaven:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.github.mayconbordin</groupId>\r\n    <artifactId>streaminer</artifactId>\r\n    <version>1.0</version>\r\n</dependency>\r\n```\r\n\r\n## Frequent Itemsets\r\n\r\n### Algorithms\r\n  - CountSketch [\\[1\\]](#ref1)\r\n  - CountMinSketch [[2]](#ref2)\r\n  - LossyCounting [[3]](#ref3)\r\n  - Majority [[4]](#ref4)\r\n  - MisraGries [[5]](#ref5)\r\n  - SpaceSaving [[6]](#ref6)\r\n  - StickySampling [[3]](#ref3)\r\n  - RealCounting\r\n  - SimpleTopKCounting\r\n\r\n### Usage\r\n\r\nExcept for the `CountMinSketchAlt` class, all algorithms implement the `IRichFrequency` interface. Here's an example using the `SpaceSaving` algorithm:\r\n\r\n```java\r\nRandom r = new Random();\r\nint counters = 20;\r\ndouble support = 0.01;\r\ndouble maxError = 0.1;\r\n\r\nIRichFrequency<Integer> counter = new SpaceSaving<Integer>(counters, support, maxError);\r\nfor (int i=0 i<1000; i++) {\r\n    counter.add(r.nextInt(100), 1);\r\n}\r\n\r\n// get the top 10 items\r\nList<CountEntry<Integer>> topk = counter.peek(10);\r\n\r\n// print the items\r\nfor (CountEntry<Integer> item : topk) {\r\n    System.out.println(item);\r\n}\r\n\r\n// get the frequency of a single item\r\nint item = 25;\r\nlong freq = counter.estimateCount(item);\r\nSystem.out.println(item + \": \" + freq);\r\n```\r\n\r\n---\r\n\r\n## Top-K\r\n\r\n### Algorithms\r\n\r\n  - StreamSummary [[6]](#ref6)\r\n  - ConcurrentStreamSummary\r\n  - Frequent\r\n  - StochasticTopper\r\n\r\n### Usage\r\n\r\nThe basic usage of a Top-K algorithm is basically the same as the frequent itemset, except that these algorithms do not support the `estimateCount` method.\r\n\r\n```java\r\nITopK<String> counter = new StreamSummary<String>(3);\r\n\r\nString[] stream = {\"X\", \"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\", \"X\", \"X\", \"A\", \"C\", \"A\", \"A\"};\r\nfor (String i : stream) {\r\n    counter.add(i);\r\n}\r\n\r\nList<CountEntry<String>> topk = counter.peek(3);\r\nfor (CountEntry<String> item : topk) {\r\n    System.out.println(item);\r\n}\r\n```\r\n\r\n---\r\n\r\n## Quantiles\r\n\r\n### Algorithms\r\n\r\n  - CKMSQuantiles [[7]](#ref7)\r\n  - Frugal2U [[8]](#ref8)\r\n  - GKQuantiles [[9]](#ref9)\r\n  - MPQuantiles [[10]](#ref10)\r\n  - QDigest [[11]](#ref11)\r\n  - WindowSketchQuantiles [[12]](#ref12)\r\n  - RSSQuantiles [[13]](#ref13)\r\n  - EnsembleQuantiles\r\n  - ExactQuantiles\r\n  - ExactQuantilesAll\r\n  - SimpleQuantiles\r\n  - SumQuantiles\r\n  - TDigest\r\n\r\n### Usage\r\n\r\n```java\r\ndouble[] quantiles = new double[]{0.05, 0.25, 0.5, 0.75, 0.95};\r\nIQuantiles<Integer> instance = new Frugal2U(quantiles, 0);\r\n\r\nRandomEngine r = new MersenneTwister64(0);\r\nNormal dist = new Normal(100, 50, r);\r\nint numSamples = 1000;\r\n        \r\nfor(int i = 0; i < numSamples; ++i) {\r\n    int num = (int) Math.max(0, dist.nextDouble());\r\n    instance.offer(num);\r\n}\r\n\r\nfor (double q : quantiles) {\r\n    System.out.println(q + \": \" + instance.getQuantile(q));\r\n}\r\n```\r\n\r\n---\r\n\r\n## Cardinality\r\n\r\n### Algorithms\r\n\r\n  - AdaptiveCounting [[14]](#ref14)\r\n  - LogLog [[15]](#ref15)\r\n  - HyperLogLog [[16]](#ref16)\r\n  - HyperLogLogPlus [[17]](#ref17)\r\n  - LinearCounting [[18]](#ref18)\r\n  - CountThenEstimate\r\n\r\n### Usage\r\n\r\n```java\r\nICardinality card = new LogLog(8);\r\n\r\nfor (int i=0; i<100; i++) {\r\n    card.offer(Math.random()*100.0);\r\n}\r\n\r\nSystem.out.println(\"Cardinality: \" + card.cardinality());\r\n```\r\n\r\n---\r\n\r\n## Average\r\n\r\n### Algorithms\r\n\r\n  - MovingAverage\r\n  - SimpleEWMA\r\n  - VariableEWMA\r\n  - TEWMA [[25]](#ref25)\r\n\r\n### Usage\r\n\r\n```java\r\n// create a EWMA with 15 seconds of age for the metrics in the period\r\nIAverage avg = new VariableEWMA(15.0);\r\n\r\nfor (int i=0; i<100; i++) {\r\n    avg.add(Math.random()*100.0);\r\n    if (i%10 == 0)\r\n        System.out.println(\"Average: \" + avg.getAverage());\r\n}\r\n```\r\n\r\n---\r\n\r\n## Membership\r\n\r\n### Algorithms\r\n\r\n  - BloomFilter [[22]](#ref22)\r\n  - CountingBloomFilter [[19]](#ref19)\r\n  - DynamicBloomFilter [[20]](#ref20)\r\n  - RetouchedBloomFilter [[21]](#ref21)\r\n  - StableBloomFilter [[23]](#ref23)\r\n  - TimingBloomFilter [[24]](#ref24)\r\n\r\n## References\r\n\r\n`[1]` <a name=\"ref1\"></a>Charikar, Moses, Kevin Chen, and Martin Farach-Colton. \"Finding frequent items in data streams.\" Automata, Languages and Programming. Springer Berlin Heidelberg, 2002. 693-703.\r\n\r\n`[2]` <a name=\"ref2\"></a>Cormode, Graham, and S. Muthukrishnan. \"An improved data stream summary: the count-min sketch and its applications.\" Journal of Algorithms 55.1 (2005): 58-75.\r\n\r\n`[3]` <a name=\"ref3\"></a>Manku, Gurmeet Singh, and Rajeev Motwani. \"Approximate frequency counts over data streams.\" Proceedings of the 28th international conference on Very Large Data Bases. VLDB Endowment, 2002.\r\n\r\n`[4]` <a name=\"ref4\"></a>M. J. Fischer and S. L. Salzberg. \"Finding a Majority Among N Votes: Solution to Problem 81-5(Journal of Algorithms, June 1981)\", Journal of Algorithms, 3:4, December 1982, pp. 362-380.\r\n\r\n`[5]` <a name=\"ref5\"></a>Misra, Jayadev, and David Gries. \"Finding repeated elements.\" Science of computer programming 2.2 (1982): 143-152.\r\n\r\n`[6]` <a name=\"ref6\"></a>Metwally, Ahmed, Divyakant Agrawal, and Amr El Abbadi. \"Efficient computation of frequent and top-k elements in data streams.\" Database Theory-ICDT 2005. Springer Berlin Heidelberg, 2005. 398-412.\r\n\r\n`[7]` <a name=\"ref7\"></a>Cormode, Graham, et al. \"Effective computation of biased quantiles over data streams.\" Data Engineering, 2005. ICDE 2005. Proceedings. 21st International Conference on. IEEE, 2005.\r\n\r\n`[8]` <a name=\"ref8\"></a>Ma, Qiang, S. Muthukrishnan, and Mark Sandler. \"Frugal Streaming for Estimating Quantiles.\" Space-Efficient Data Structures, Streams, and Algorithms. Springer Berlin Heidelberg, 2013. 77-96.\r\n\r\n`[9]` <a name=\"ref9\"></a>Greenwald, Michael, and Sanjeev Khanna. \"Space-efficient online computation of quantile summaries.\" ACM SIGMOD Record. Vol. 30. No. 2. ACM, 2001.\r\n\r\n`[10]` <a name=\"ref10\"></a>Munro, J. Ian, and Mike S. Paterson. \"Selection and sorting with limited storage.\" Theoretical computer science 12.3 (1980): 315-323.\r\n\r\n`[11]` <a name=\"ref11\"></a>Shrivastava, Nisheeth, et al. \"Medians and beyond: new aggregation techniques for sensor networks.\" Proceedings of the 2nd international conference on Embedded networked sensor systems. ACM, 2004.\r\n\r\n`[12]` <a name=\"ref12\"></a>Arasu, Arvind, and Gurmeet Singh Manku. \"Approximate counts and quantiles over sliding windows.\" Proceedings of the twenty-third ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems. ACM, 2004.\r\n\r\n`[13]` <a name=\"ref13\"></a>Gilbert, Anna C., et al. \"How to summarize the universe: Dynamic maintenance of quantiles.\" Proceedings of the 28th international conference on Very Large Data Bases. VLDB Endowment, 2002.\r\n\r\n`[14]` <a name=\"ref14\"></a>Cai, Min, et al. \"Fast and accurate traffic matrix measurement using adaptive cardinality counting.\" Proceedings of the 2005 ACM SIGCOMM workshop on Mining network data. ACM, 2005.\r\n\r\n`[15]` <a name=\"ref15\"></a>Durand, Marianne, and Philippe Flajolet. \"Loglog counting of large cardinalities.\" Algorithms-ESA 2003. Springer Berlin Heidelberg, 2003. 605-617.\r\n\r\n`[16]` <a name=\"ref16\"></a>Flajolet, Philippe, et al. \"HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm.\" DMTCS Proceedings 1 (2008).\r\n\r\n`[17]` <a name=\"ref17\"></a>Heule, Stefan, Marc Nunkesser, and Alexander Hall. \"HyperLogLog in practice: algorithmic engineering of a state of the art cardinality estimation algorithm.\" Proceedings of the 16th International Conference on Extending Database Technology. ACM, 2013.\r\n\r\n`[18]` <a name=\"ref18\"></a>Whang, Kyu-Young, Brad T. Vander-Zanden, and Howard M. Taylor. \"A linear-time probabilistic counting algorithm for database applications.\" ACM Transactions on Database Systems (TODS) 15.2 (1990): 208-229.\r\n\r\n`[19]` <a name=\"ref19\"></a>Fan, L., Cao, P., Almeida, J., & Broder, A. Z. (2000). Summary cache: a scalable wide-area web cache sharing protocol. IEEE/ACM Transactions on Networking (TON), 8(3), 281-293.\r\n\r\n`[20]` <a name=\"ref20\"></a>Guo, Deke, Jie Wu, Honghui Chen, and Xueshan Luo. \"Theory and Network Applications of Dynamic Bloom Filters.\" In INFOCOM, pp. 1-12. 2006.\r\n\r\n`[21]` <a name=\"ref21\"></a>Donnet, Benoit, Bruno Baynat, and Timur Friedman. \"Retouched bloom filters: allowing networked applications to trade off selected false positives against false negatives.\" In Proceedings of the 2006 ACM CoNEXT conference, p. 13. ACM, 2006.\r\n\r\n`[22]` <a name=\"ref22\"></a>Bloom, Burton H. \"Space/time trade-offs in hash coding with allowable errors.\" Communications of the ACM 13, no. 7 (1970): 422-426.\r\n\r\n`[23]` <a name=\"ref23\"></a>Deng, Fan, and Davood Rafiei. \"Approximately detecting duplicates for streaming data using stable bloom filters.\" Proceedings of the 2006 ACM SIGMOD international conference on Management of data. ACM, 2006.\r\n\r\n`[24]` <a name=\"ref24\"></a>Dautrich Jr, Jonathan L., and Chinya V. Ravishankar. \"Inferential time-decaying Bloom filters.\" Proceedings of the 16th International Conference on Extending Database Technology. ACM, 2013.\r\n\r\n`[25]` <a name=\"ref25\"></a>Martin, Ruediger, and Michael Menth. \"Improving the Timeliness of Rate Measurements.\" In MMB, pp. 145-154. 2004.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}